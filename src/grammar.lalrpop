use crate::ast::*;

grammar;

Comma<T>: Vec<T> = { 
    <v:(<T> ",")*> <e:T?> => match e {
        None=> v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

// TODO: Unify this with Comma, and keep track of weather we have a trailing semi (if we want that)
Semi<T>: Vec<T> = { 
    <v:(<T> ";")*> <e:T?> => match e {
        None=> v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};


pub Program: Program<'input>  = { <Item*> }

pub Item: Item<'input> = {
    <Function> => Item::Function(<>)
}

pub Function: Function<'input> = {
    "fn" <name:Name> <args:Args> <ret:("->" <Type> )?> <body:Body> => Function{<>}
}

Args = { "(" <Comma<Arg>> ")"  }

// TODO: Maybe dont have names things, use a tuple, not a struct.
Arg: Arg<'input> = { <name:Name> ":" <ty:Type> => Arg{<>} }

Type: Type = {
    "int" => Type::Int,
    "bool" => Type::Bool,
    "string" => Type::String,
}

Name = { r"[a-zA-Z][a-zA-Z0-9_]*" }

Body = { "{" <Semi<Stmt>> "}" }

// TODO: Should these be exprs? Should we have stmts?
pub Stmt: Stmt<'input> = {
    <Expr> => Stmt::Expr(<>),
    "let" <Name> "=" <Expr> => Stmt::Let(<>),
    "print" <Expr> => Stmt::Print(<>),
    "return" <Expr> => Stmt::Return(<>),
}

// Rename for convenience
pub Expr = { <OrExpr> }
BExpr: Box<Expr<'input>> = { <Expr> => Box::new(<>) }

// See http://www.craftinginterpreters.com/appendix-i.html
// https://cs.wmich.edu/~gupta/teaching/cs4850/sumII06/The%20syntax%20of%20C%20in%20Backus-Naur%20form.htm



Tier<Op,NextTier>: Expr<'input> = {
    <l:Tier<Op,NextTier>> <o:Op> <r:NextTier> => Expr::BinOp(Box::new(l), o, Box::new(r)),
    NextTier
};

OrExpr            = Tier<LogicalOr,        AndExpr>;
AndExpr           = Tier<LogicalAnd,       EqualityExpr>;
EqualityExpr      = Tier<EqualityOp,       ComparisonExpr>;
ComparisonExpr    = Tier<ComparisonOp,     AdditiveExpr>;
AdditiveExpr      = Tier<AdditionOp,       MultiplicitveExpr>;
MultiplicitveExpr = Tier<MultiplicationOp, UnaryExpr>;


UnaryExpr: Expr<'input> = {
    <PostfixExpr>,
    <o:UnaryOp> <e:UnaryExpr> => Expr::UnaryOp(o, Box::new(e)),
}

PostfixExpr: Expr<'input> = {
    <BaseExpr>,
    <l:PostfixExpr> "[" <r:Expr> "]" => Expr::ArrayAccess(Box::new(l), Box::new(r)),
    <l:PostfixExpr> "(" <r:Comma<Expr>> ")" => Expr::Call(Box::new(l), r),
    <l:PostfixExpr> "." <r: Name> => Expr::FieldAccess(Box::new(l), r),
}

BaseExpr: Expr<'input> = {
    // TODO: Else if
    "if" <BExpr> <Body> <("else" <Body>)?> => Expr::If(<>),
    "for" <Name> "in" <BExpr> <Body> => Expr::For(<>),
    "while" <BExpr> <Body> => Expr::While(<>),
    <Name> => Expr::Var(<>),
    <Body> => Expr::Block(<>),
    "(" <Expr> ")" => <>,
    <Literal> => Expr::Literal(<>) 
}

Literal: Literal<'input> = {
    <s:StringLit> => Literal::String(&s[1..s.len()-1]),
    <FloatLit> => Literal::Float(<>.parse().unwrap()),
    <IntLit> => Literal::Integer(<>.parse().unwrap()),
    <BoolLit> => Literal::Bool(<>)
}

// https://stackoverflow.com/a/2039820
StringLit = { r#""(\\.|[^"\\])*""# }
FloatLit = { r#"[+-]?[0-9]+[.][0-9]*"# }
IntLit = { r"[0-9]+" }
BoolLit: bool = {
    "true" => true,
    "false" => false
}


LogicalOr:         BinOp = { "||" => BinOp::LogicalOr }
LogicalAnd:        BinOp = { "&&" => BinOp::LogicalAnd }
Equals:            BinOp = { "==" => BinOp::Equals }
NotEquals:         BinOp = { "!=" => BinOp::NotEquals }
LessThan:          BinOp = { "<"  => BinOp::LessThan }
GreaterThan:       BinOp = { ">"  => BinOp::GreaterThan }
LessThanEquals:    BinOp = { "<=" => BinOp::LessThanEquals }
GreaterThanEquals: BinOp = { ">=" => BinOp::GreaterThanEquals }
Plus:              BinOp = { "+"  => BinOp::Plus }
Minus:             BinOp = { "-"  => BinOp::Minus }
Times:             BinOp = { "*"  => BinOp::Times }
Devide:            BinOp = { "/"  => BinOp::Devide }

// UnaryMinus: UnaryOp = { "-" => UnaryOp::Minus }
// UnaryNot:   UnaryOp = { "-" => UnaryOp::Not }

EqualityOp: BinOp = { <Equals>, <NotEquals> }
ComparisonOp: BinOp = { <LessThan>, <GreaterThan>, <LessThanEquals>, <GreaterThanEquals> }
AdditionOp: BinOp = { <Plus>, <Minus> }
MultiplicationOp: BinOp = { <Times>, <Devide> }

// Somehow, doing the thing we did with BinOps gives a lalrpop error about ambiguitys
UnaryOp: UnaryOp = {
    "!" => UnaryOp::Not,
    "-" => UnaryOp::Minus,
}
