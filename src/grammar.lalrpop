use crate::ast::*;

grammar;

Comma<T>: Vec<T> = { 
    <v:(<T> ",")*> <e:T?> => match e {
        None=> v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

// TODO: Unify this with Comma, and keep track of weather we have a trailing semi (if we want that)
Semi<T>: Vec<T> = { 
    <v:(<T> ";")*> <e:T?> => match e {
        None=> v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

pub Function: Function<'input> = {
    "fn" <name:Name> <args:Args> <ret:("->" <Type> )?> <body:Body> => Function{<>}
}

Args = { "(" <Comma<Arg>> ")"  }

// TODO: Maybe dont have names things, use a tuple, not a struct.
Arg: Arg<'input> = { <name:Name> ":" <ty:Type> => Arg{<>} }

Type: Type = {
    "int" => Type::Int,
    "bool" => Type::Bool,
    "string" => Type::String,
}

Name = { r"[a-z]+" }

Body = { "{" <Semi<Stmt>> "}" }

// TODO: Move to expression oriented
Stmt: Stmt<'input> = {
    // Expr statement
    <Expr> => Stmt::Expr(<>),
    // Let statement
    "let" <Name> "=" <Expr> => Stmt::Let(<>),
    // Controll flow
    "if" <Expr> <Body> <("else" <Body>)?> => Stmt::If(<>),
    "for" <Name> "in" <Expr> <Body> => Stmt::For(<>),
    "print" <Expr> => Stmt::Print(<>),
    "while" <Expr> <Body> => Stmt::While(<>),
    "return" <Expr> => Stmt::Return(<>),
}

Expr: Expr<'input> = {
    Name => Expr::Var(<>),
    Body => Expr::Block(<>)
}


LogicalOr:         BinOp = { "||" => BinOp::LogicalOr }
Equals:            BinOp = { "==" => BinOp::Equals }
NotEquals:         BinOp = { "!=" => BinOp::NotEquals }
LessThan:          BinOp = { "<"  => BinOp::LessThan }
GreaterThan:       BinOp = { ">"  => BinOp::GreaterThan }
LessThanEquals:    BinOp = { "<=" => BinOp::LessThanEquals }
GreaterThanEquals: BinOp = { ">=" => BinOp::GreaterThanEquals }
Plus:              BinOp = { "+"  => BinOp::Plus }
Minus:             BinOp = { "-"  => BinOp::Minus }
Times:             BinOp = { "*"  => BinOp::Times }
Devide:            BinOp = { "."  => BinOp::Devide }

UnaryMinus: UnaryOp = { "-" => UnaryOp::Minus }
UnaryNot:   UnaryOp = { "-" => UnaryOp::Not }